# 第四周学习笔记

### 刷题集合

#### 简单题集合

|   题号  | 刷题次数   |  技巧点  |
| --------   | -----:  | :----:|
|[392.判断子序列](https://leetcode-cn.com/problems/is-subsequence/)|3|双指针数组遍历|
|[70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)|3|动态规划|
|[53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)|3|动态规划|(与不限交易次数的股票问题相同)
|[198.打家劫舍](https://leetcode-cn.com/problems/house-robber/)|3|动态规划（二维）|（每天必看）

#### 中等题集合

|   题号  | 刷题次数   |  技巧点  |
| --------   | -----:  | :----:|
|[62.不同路径](https://leetcode-cn.com/problems/unique-paths/)|3|动态规划|
|[63.不同路径-2](https://leetcode-cn.com/problems/unique-paths-ii/)|3|动态规划|
|[120.三角形最小路径和](https://leetcode-cn.com/problems/triangle/description/)|3|动态规划|
|[152.乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)|3|动态规划|
|[322.零钱兑换](https://leetcode-cn.com/problems/coin-change/)|3|动态规划（自底向上）|
|[1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)|3|动态规划（比较最后一个字符）|
|[213.打家劫舍-2](https://leetcode-cn.com/problems/house-robber-ii/description/)|3|动态规划|
|[股票交易系列问题](https://u.geekbang.org/lesson/25?article=255979)|3|动态规划（每天必看）|
|[64.最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)|3|二维数组动态规划|
|[221.最大正方形](https://leetcode-cn.com/problems/maximal-square/)|3|二维数组动态规划（长方形的右下角）|
|[647.回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)|3|二维数组动态规划（长方形的右下角）|

#### 困难题集合

|   题号  | 刷题次数   |  技巧点  |
| --------   | -----:  | :----:|
|[392.判断子序列](https://leetcode-cn.com/problems/is-subsequence/)|3|双指针数组遍历|
|[32.最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)|3|动态规划/栈|
|[72.编辑距离](https://leetcode-cn.com/problems/edit-distance/)|3|二维动态规划|
|[403.青蛙问题](https://leetcode-cn.com/problems/frog-jump/)|3|二维动态规划（与set结合）|

### 动态规划的实现及其关键点

1. 人肉递归效率低
2. 找到最近最简方法，将其拆解成可重复子问题
3. 数学归纳法思维
**本质：寻找重复性->计算机指令集**

#### 动态规划关键点
动态规划和递归，分治没有根本上的区别（关键看有无最优子结构）
**共性：找到重复子问题**
差异性：最优子结构，中途可以淘汰次优解

斐波拉契数列的傻递归的时间复杂度为O(2^n)

1. 最优子结构 opt[n] = best_of(opt[n-1],opt[n-2],...)
2. 储存中间状态：opt[i]
3. 递推公式（动态规划状态方程）
	Fib:opt[i] = opt[n-1] + opt[n-2]
	二维路径：opt[i,j] = opt[i+1][j] + opt[i][j+1](判断a[i,j]是否为空地)
	
#### 最长公共子序列思路
1. 将两个字符串化成二维数组的形式。
2. 拆解成子问题。先枚举**a字符串的子串**与b字符串的最长公共子序列。再求得a字符串与枚举**b字符串的子串**的最长公共序列。
3. 相当于将一个完整的求最长公共子序列拆解成多个最长公共子序列。
4. 每组比较中，比较两字符串的最后一个字符。若相等。则当前最长公共子序列为dp[i-1][j-1]+1。
   这是因为，最后一个字符已然相等，加上两字符串之前的最长公共子序列即为当前的最长公共子序列。
5. 若最后一个字符不相等，则通过max(dp[i-1][j],dp[i][j-1])得到最长子序列。

#### 三角形的最小路径思路
1. 重复性（分治） problem(i,j) = min(sub(i+1,j),sub(i+1,j+1)) + a(i,j)
2. 定义状态数组：f[i,j] // 记录各阶段的最小路径
3. DP方程：f[i,j] = min(f[i+1,j],f[i+1,j+1]) + a[i,j]

#### 最大子序和思路
1. 重复性(分治)  problem_sum(i) = max_sum(problem_sum(i-1) + a(i),a(i));  // 求当前最大子序列之和，相当于求**包含该元素后**的最大子序列和以及**不包含该元素**的最大子序列之和的最大值
           或者  problem_sum(i) = max_sum(problem_sum(i-1),0) + a(i); //两种写法中心思想一样
2. 定义状态数组：sum[i]
3. DP方程：sum[i] = max(sum[i-1] + a[i],a[i]);

#### 零钱兑换思路
我们采用自底向上的动态规划方法
我们要求组成11的最少硬币数，可以考虑组合中的最后一个硬币分别是1，2，5的情况，比如

- 最后一个硬币是1的话，最少硬币数应该为【组成10的最少硬币数】+ 1枚（1块硬币）
- 最后一个硬币是2的话，最少硬币数应该为【组成9的最少硬币数】+ 1枚（2块硬币）
- 最后一个硬币是5的话，最少硬币数应该为【组成6的最少硬币数】+ 1枚（5块硬币）
在这3种情况中硬币数最少的那个就是结果
按同样的道理，我们也可以分别再求出组成10的最少硬币数，组成9的最少硬币数，组成6的最少硬币数。。。
发现了吗，这种当前状态的问题可以转化成之前状态问题的，一般就是动态规划的套路
所以我们自底向上依次求组成1，2...一直到11的最少硬币数
对每一个数，依次比较最后一个硬币是不同面额的情况，从中选出最小值
⚠️注意：这里有两个小技巧：

dp数组记录凑出当前零钱总数的最小硬币数。
预设一个0位方便后续计算，组成0的最少硬币数是0，所以dp[0] = 0，所以设定的dp数组有12个元素。多了一个0元素
给每一个数预设一个最大值amount+1，因为硬币面额最小为整数1，所以只要有解，最小硬币数必然小于amount+1
dp的最后一项就是答案，即dp[11]。

#### 打家劫舍问题思路
状态数组a[i] 代表从0到i能偷到的最大金额
初步考虑，需要考虑两种情况，即当前索引下的房子偷不偷，因此需要将一维数组转变成二维数组
a[i][0]表示索引到第i个房子，且不偷第i个房子情况下的利润值
a[i][1]表示索引到第i个房子，且偷第i个房子情况下的利润值
根据所加的条件，相关的状态转移方程可写成
a[i][0] = max(a[i-1][0],a[i-1][1]) 因为当前索引下的房子不偷，因此当前利润为之前房子操作后的**利润和**。也是分两种情况，即偷与不偷
a[i][1] = a[i-1][0] + nums[1] 当前索引下的房子要被偷，因此前一个房子肯定不能偷。
最后比较max(a[n-1][0],a[n-1][1])即得到最大的利润值
初始化a[0][0] = 0 第0个房子不偷，利润为0
a[0][1] = nums[0] 第0个房子偷，利润为利润数组的第一个元素
之后，可以考虑将二维数组压缩到一维数组，个人认为，二维数组是将各阶段的利润和累加，且保存下来各阶段的利润和。最终数组最后一位就是最大利润
一维数组含义将发生变化，**a[i]表示当前循环到i编号的房子了，因此a[i]代表循环到i房子的前提下可以获得的最大利润，两种情况进行对比**

#### 股票买卖系列问题思路
1. 只允许一次买卖，即遍历一次数组。不断更新最大利润值(当前股价与最低股价的差值，最低股价必须在当前股价前面)。同时更新最低股价信息
2. 可以允许无数次交易，则利用贪心思想，只要后一天的股价比买进时的股价高就卖出，最后求出总的利润值。
3. 只允许两次交易的，借用三维数组的动态规划dp[n][2][3] 代表第n天，2个状态（0不持有，1持有），**当前已完成的**交易次数（0，1，2）、
   最后返回，最后一天，最多允许 K 次交易，最多获得多少利润。

#### 最长有效括号思路

**方法一：栈**
有效括号的长度，都是成对出现的，即2的倍数。
可以建立一个栈，用于存储字符串数组的元素下标，初始化时，将-1首先压入栈。
之后，遍历数组，若碰到'('，则把对应的元素下标压入栈。
若碰到')'，则首先将栈顶元素弹出，然后判断此刻的栈是否为空，若不为空，计算i - st.top()即为当前的有效长度
若此时栈已经为空，则将该')'元素下标压入栈。
计算一次当前累计的有效长度后，更新maxlenth。

**方法二：动态规划**
建立dp数组，明确这里的dp数组语义，这里建立一个长度与字符串长度一致的dp数组。用于记录每个字符元素对应的最长有效括号长度。
这里规定，我们只记录')'元素对应的最长长度。碰到'('时，设置dp数组对应的元素为0。
**状态转移方程**
dp[i] = 2 + dp[i-1] + dp[i - dp[i-1]-2]
- 2表示当前循环到了')'，且已经找到了与')'匹配的左括号。这时的括号长度已经有了2。
- dp[i-1]检查该元素内部是否有有效的括号长度
- 检查字符串的剩余部分是否还有有效括号长度。
总和即为当前元素对应的最长有效括号长度
**遍历数组时从索引1开始遍历，因为0处对应的dp数组元素都是0**

#### 青蛙问题解决思路
这个问题可以结合跳跃游戏问题思考。不同点是。跳跃游戏的数组元素是可以跳跃的长度，我们关心当前的跳跃长度是否可以**按照索引**到达最后
青蛙问题的跳跃长度为k-1,k,k+1。数组元素为**需要到达的位置**，我们每计算一次，都需要跟具体元素比较，看跳跃后的位置是否满足元素的值
**思路**
- 设置一个二维dp数组，数组中的行的索引号代表石头所在的位置，即stones数组中的元素
- 数组的列设定为set数组，用于储存到达当前石头所在处的步数集合
- 循环遍历stones数组中的元素，最终查验dp数组的最后一个元素是否为空即可
- **注意：二维数组的索引号代表石头所在地！！！不是stones的索引号，而是stones数组的具体元素。**
- 循环dp数组中某石头所在地的集合中的元素，即步数
- 分别计算从当前位置出发，前进k-1,k,k+1步，得到可以到达的位置，之后更新dp数组的后续元素        
- 注意，我们在得到下一阶段可到达的位置信息，**可能不在stones数组中**，这不重要，我们只需按步骤循环完stones数组中的每一个元素，最后查看dp数组中最后一个石头元素是否为空即可